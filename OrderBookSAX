package pkg;

/**
 * Created by Admin on 25.06.2015.
 */
// Import File object to work with xml file
import java.io.File;

// Import Document object interface to store parsed file
import org.w3c.dom.*;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

// Import xml parser
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;


// Import list data-structure
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// Import Map data-structure


public class OrderBookSAX extends DefaultHandler {
/*
    // Configure xml file name or path
    private static String xmlFileName = "C:\\Users\\Admin\\Documents\\orders.xml";

    static Document doc = null;
*/
    // Create new Map structure to store lists
    private static Map<String, List> listMap = new HashMap();


    ///public class MySaxParser extends DefaultHandler {
    List<Transaction> transactL;
    String transactionXMLFileName;
    String tmpValue;
    Transaction transactionTmp;

    public OrderBookSAX(String xmlFileName) {
        this.transactionXMLFileName = xmlFileName;
        transactL = new ArrayList<Transaction>();
        parseDocument();
        printDatas();
    }

    private void parseDocument() {
        //parse
        SAXParserFactory factory = SAXParserFactory.newInstance();
        try {
            SAXParser parser = factory.newSAXParser();
            parser.parse(transactionXMLFileName, this);
        } catch (ParserConfigurationException e) {
            System.out.println("ParcerConfig error");
        } catch (SAXException e) {
            System.out.println("SAXException : xml not well formed");
        } catch (IOException e) {
            System.out.println("IO error");
        }
    }

    private void printDatas() {
        //System.out.printkn(bookL.size());
        for (Transaction tmpTrn : transactL) {
            System.out.println(tmpTrn.getOrderID() + "   " + tmpTrn.getVolume() +  "   " + tmpTrn.getPrice() +  "   " + tmpTrn.operationType);
        }
    }
    @Override
    public void startElement(String s, String s1, String elementName, Attributes attributes)
            throws SAXException {
        //if current element is transaction, create new transaction
        //clear tmpValue on start of element

        if (elementName.equalsIgnoreCase("AddOrder")) {
            transactionTmp = new Transaction(attributes.getValue("operation"));
            transactionTmp.setPrice(Double.parseDouble(attributes.getValue("price")));
            transactionTmp.setVolume(Integer.parseInt(attributes.getValue("volume")));
            transactionTmp.setOrderID(Integer.parseInt(attributes.getValue("orderId")));
        }
    }
    @Override
    public void endElement(String s, String s1, String element) throws SAXException {
        if (element.equals("AddOrder")){
            transactL.add(transactionTmp);
        }
    }

    @Override
    public void characters(char[] ac, int i, int j) throws SAXException {
        tmpValue = new String(ac, i, j);
    }


    public static void main(String[] args) {


        /*try {
            // Be nice and say hello
            log("Hello!");


            // Parse xml file
            loadXML(xmlFileName);


            NodeList nodeList = doc.getElementsByTagName("Orders");
            log("___________________nodeList" + nodeList.getLength());
            if (doc.hasChildNodes()) {
                doNode(doc.getChildNodes());
            }
            printListMap(listMap);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }*/
        new OrderBookSAX("C:\\Users\\Admin\\Documents\\orders01.xml");

    }



/*







    private static void doNode(NodeList nodeList) {
        // Create new list instance
        List transactionList = new LinkedList();

        log("___________________nodeList: " + nodeList.getLength());
        // Iterate over list of nodes that we get from file and create transactions list
        for (int count = 0; count < nodeList.getLength(); count++) {
            // Get current item from the list of nodes
            Node fstNode = nodeList.item(count);

            // Check if node is not null
            if (fstNode.getNodeType() == Node.ELEMENT_NODE) {

                // create String variable bookName for store current book name
                String bookName = "";
                if (fstNode.hasAttributes() && (fstNode.getNodeName() == "AddOrder")) {
                    // Create variable for check book
                    NamedNodeMap nodeMap = fstNode.getAttributes();
                    Transaction newTransaction = null;
                    for (int i = 0; i < nodeMap.getLength(); i++) {

                        Node node = nodeMap.item(i);

                        //check if attribute name equal book
                        if (node.getNodeName() == "book") {
                            bookName = node.getNodeValue();

                            // Get transactionList with current book
                            transactionList = listMap.get(bookName);

                            // Check if listMap with current book exists
                            if (listMap.get(bookName) == null) {

                                // Create new list instance with current book if not exists
                                transactionList = new LinkedList();
                            }
                        }
                        //check if attr name equal orderId create new instance of transaction class
                        if (node.getNodeName() == "orderId") {
                            // Create new instance of transaction class
                            newTransaction.setOrderID(Integer.parseInt(node.getNodeValue()));
                        }

                        // Add properties to the Transaction
                        // If attr name equal volume set quantity of books
                        if (node.getNodeName() == "volume") {
                            newTransaction.setVolume(Integer.parseInt(node.getNodeValue()));
                        }
                        // If attr name equal price set price
                        if (node.getNodeName() == "price") {
                            newTransaction.setPrice(Double.parseDouble(node.getNodeValue()));
                        }
                        // If attr name equal operation set operation type
                        if (node.getNodeName() == "operation") {
                            newTransaction = new Transaction(node.getNodeValue());
                        }
                        if (i == (nodeMap.getLength() - 1)) {

                            // Show transaction info in the console
                            */
/*log("Transaction orderID: " + newTransaction.getOrderID() + "\n");
                            log("Transaction operation: " + newTransaction.operationType + "\n");
                            log("Transaction volume: " + newTransaction.getVolume() + "\n");
                            log("Transaction price: " + newTransaction.getPrice() + "$\n");
                            log("Book: " + listMap.get(bookName) + "\n");
                            System.out.print("\n\n");

*//*

                            Integer iVolume = findAndReleaseTransaction(listMap, bookName, newTransaction.operationType,
                                    newTransaction.getVolume(), newTransaction.getPrice());
                            if (iVolume != null) {
                                newTransaction.setVolume(iVolume);
                            }
                            // If volume > 0 add new transaction to the list of orders
                            if (((iVolume != null) && (iVolume > 0)) || (iVolume == null)) {
                                transactionList.add(newTransaction);
                            }
                            //listMap.get(bookName);
                            //printListMap(listMap);



                            // Check populated list length
                            ///log("List length after population: " + transactionList.size());

                            // Add new list to the map structure with key
                            listMap.put(bookName, transactionList);

                            // Check empty map length
                            ///log("Map length after population: " + listMap.size());

                            // Check that map returns list by its key
                            List returnList = (List) listMap.get(bookName);
*/
/*                            log("Size of the List returned by map for 'book' key: " + returnList.size());
                            log("++++Map+++++++" + listMap.entrySet());
                            System.out.println("size " + returnList.size());*//*

                            for (int j = 0; j < returnList.size(); j++) {
                                Transaction tr2 = (Transaction) returnList.get(0);
                            }
                        }
                    }
                }
                if (fstNode.hasAttributes() && (fstNode.getNodeName() == "DeleteOrder")) {


                    // Create variable for check book
                    NamedNodeMap nodeMap = fstNode.getAttributes();
                    Transaction newTransaction = null;
                    String bkName = "";
                    Integer iOrderId = null;
                    for (int i = 0; i < nodeMap.getLength(); i++) {

                        Node node = nodeMap.item(i);

                        //check if attribute name equal book
                        if (node.getNodeName() == "book") {
                            bkName = node.getNodeValue();
                        }

                        if (node.getNodeName() == "orderId") {

                            iOrderId = Integer.parseInt(node.getNodeValue());
                        }

                        if ((i == (nodeMap.getLength() - 1))&&(bkName != "")) {

                            // Get transactionList with current book
                            transactionList = listMap.get(bkName);


                            if (iOrderId != null){
                                findAndDeleteTransaction(listMap, bkName, iOrderId);
                            }

                            //printListMap(listMap);
*/
/*
                            // Check populated list length
                            log("List length after population: " + transactionList.size());*//*


                            // Add new list to the map structure with key
                            listMap.put(bkName, transactionList);
*/
/*
                            // Check empty map length
                            log("Map length after population: " + listMap.size());*//*


                            // Check that map returns list by its key
                            List returnList = (List) listMap.get(bkName);

                           */
/* log("Size of the List returned by map for 'book' key: " + returnList.size());
                            log("++++Map+++++++" + listMap.entrySet());
                            System.out.println("size " + returnList.size());*//*

                            for (int j = 0; j < returnList.size(); j++) {
                                Transaction tr2 = (Transaction) returnList.get(0);
                            }
                        }
                    }
                }
            }
            if (fstNode.hasChildNodes()) {

                // loop again if has child nodes
                doNode(fstNode.getChildNodes());

            }
        }

    }

    // Function that find operations for realise. Negative operation Type
    private static Integer findAndReleaseTransaction(Map listMap, String bookName, String operationType,
                                                     Integer volume, Double price) {
        Integer result = null;
        if (bookName != null) {
            List returnList = (List) listMap.get(bookName);
            if (returnList != null) {
                for (int i = 0; i < returnList.size(); i++) {
                    Transaction tr = (Transaction) returnList.get(i);
                    //if new operation buy
                    if (tr.operationType.equals("BUY") && operationType.equals("SELL") &&
                            (tr.price >= price)) {
                        // check if volume in new transaction better than found transaction
                        if (volume >= tr.getVolume()) {
                            // remove found transaction
                            returnList.remove(i);
                            // return result as volume in new transaction minus volume in found transaction
                            result = (volume - tr.getVolume());
                        }
                        // check if volume in new transaction less than found transaction
                        else if (volume < tr.getVolume()) {
                            // set volume in found transaction
                            tr.setVolume(tr.getVolume() - volume);
                            // return 0. that means new transaction not added
                            result = 0;
                        }
                    }
                    //if new operation buy
                    if (tr.operationType.equals("SELL") && operationType.equals("BUY") &&
                            (tr.price <= price)) {
                        // check if volume in new transaction better than found transaction
                        if (volume >= tr.getVolume()) {
                            // remove found transaction
                            returnList.remove(i);
                            // return result as volume in new transaction minus volume in found transaction
                            result = (volume - tr.getVolume());
                        }
                        // check if volume in new transaction less than found transaction
                        else if (volume < tr.getVolume()) {
                            // set volume in found transaction
                            tr.setVolume(tr.getVolume() - volume);
                            // return 0. that means new transaction not added
                            result = 0;
                        }
                    }
                }
            }
        }
        return result;
    }


    // Function that find operations and delete it
    private static void findAndDeleteTransaction(Map listMap, String bookName, Integer orderId) {
        if (bookName != null) {
            List returnList = (List) listMap.get(bookName);
            if (returnList != null) {
                for (int i = 0; i < returnList.size(); i++) {
                    Transaction tr = (Transaction) returnList.get(i);
                    //if new operation buy
                    if (tr.getOrderID() == orderId) {
                        returnList.remove(i);
                    }
                }
            }
        }
    }

    // Function that logs string to the console
    private static void log(String string) {
        System.out.println(string);
    }

    // Function that takes a filepath string and returns parsed xml file
    private static void loadXML(String filepath) {
        File xmlFile;
        // Load file object into memory
        try {
            xmlFile = new File(filepath);

            // Check that file exists and is not a directory
            if (xmlFile.exists() && xmlFile.isFile()) {
                // Log loaded file info
                log("\n-- XML file was loaded succesfully --");
                log("File name: " + xmlFile.getName());
                log("Can read: " + xmlFile.canRead());
                log("Can write: " + xmlFile.canWrite());
                log("Can execute: " + xmlFile.canExecute());
                log("-- \n");

                // Parse file after it is loaded
                doc = parseXML(xmlFile);

                ///
                System.out.println("Root element :" + doc.getDocumentElement().getNodeName());
                ///

            } else {
                throw new Error("XML file does not exist at the given path");
            }

        } catch (NullPointerException e) {
            // If xmlFileName is null - show error
            log("Error: XML file name should not be null.");
        }
    }

    // This function takes in plain File object and parses it into xml Document object
    private static Document parseXML(File xmlFile) {

        // Create new instance of DocumentBuilderFactory to create parser for xml
        DocumentBuilderFactory parserBuilder = DocumentBuilderFactory.newInstance();

        // Create an instance of Document builder to parse input file
        try {
            DocumentBuilder parser = parserBuilder.newDocumentBuilder();

            // Parse File into Document
            try {
                Document parsedXml = parser.parse(xmlFile);

                log("\n-- XML file was parsed successfully --");
                log("XML Version: " + parsedXml.getXmlVersion());
                log("XML Encoding: " + parsedXml.getXmlEncoding());
                log("--\n");

                return parsedXml;
            } catch (Exception e) {
                log("Error: Failed to parse XML file.");
                return null;
            }

        } catch (ParserConfigurationException e) {
            log("Error: Failed to setup XML parser.");
            return null;
        }
    }

    private static void printListMap(Map<String, List> listMap) {
        for (Map.Entry entry : listMap.entrySet()) {
            System.out.println("             Map.Entry entry " + entry.getKey() + " - " + entry.getValue());
            LinkedList localLinkList = (LinkedList) entry.getValue();
            for (int j = 0; j < localLinkList.size(); j++) {
                Transaction tr = (Transaction) localLinkList.get(j);
                System.out.println("             Order id: " + tr.getOrderID() + ", Volume: " + tr.getVolume() + ", Price: " + tr.getPrice() + ", Operation Type: " + tr.operationType);
            }
        }
    }
*/
    static class Transaction {
        // Store orderID
        private Integer orderID;
        // Store amount of books in that order
        private Integer volume;
        // Store book price
        private Double price;
        // Store operation type
        public String operationType;

        // Class constructior
        public Transaction (String operationType) {
            // Assign received operationType to the order
            this.operationType = operationType;
        }

        // Create property setters
        public void setVolume(Integer volume) { this.volume = volume; }

        public void setPrice(Double price) { this.price = price; }

        public void setOrderID(Integer orderID) { this.orderID = orderID; }

        // Create property getters
        public Integer getVolume() { return this.volume; }

        public Double getPrice() { return this.price; }

        public Integer getOrderID() { return this.orderID; }
    }
}
